# 给$N \times 3$网格图涂色的方案数

## 题目描述

你有一个$n \times 3$的网格图$grid$，你需要用**红，黄，绿**三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。

给你网格图的行数$n$。

请你返回给$grid$涂色的方案数。由于答案可能会非常大，请你返回答案对$10^9 + 7$取余的结果。

### 示例1

**输入**
```
n = 1
```
**输出**
```
12
```
**解释**
```
总共有12中可行方法
```
![不同的涂色方案数](images/color.png)

### 示例2

**输入**
```
n = 2
```
**输出**
```
54
```

### 示例3

**输入**
```
n = 3
```
**输出**
```
246
```

### 示例4

**输入**
```
n = 7
```
**输出**
```
106494
```

### 示例5

**输入**
```
n = 5000
```
**输出**
```
30228214
```

**备注**
- $n == grid.length$
- $grid[i].length == 3$
- $1 <= n <= 5000$

## 解释说明

当只有一行时，涂色方案可以列举出来（$0, 1, 2$分别表示不同的颜色）
```
010, 012, 020, 021, 101, 102, 120, 121, 201, 202, 210, 212
```
从上述排列中，我们可以将排列方式分为```ABC```和```ABA```两种。

- 假设当前行为```ABC```排列，那么下一行可以是```BCA, CAB, BAB, BCB```。
- 假设当前行为```ABA```排列，那么下一行可以是```BAB, CAC, BCB, BAC, CAB```。

所以，我们可以得到递推公式
$$f[i][0] = 2 \times f[i - 1][0] + 2 \times f[i - 1][1] \\ f[i][1] = 2 \times f[i - 1][0] + 3 \times f[i - 1][1]$$

```C++
class Solution {
private:
    static constexpr int mode = 1e9 + 7;
public:
    int numOfWays(int n) {
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = dp[0][1] = 6;
        for (int idx = 1; idx < n; idx++){
            dp[idx][0] = (2LL * dp[idx - 1][0] + 2LL * dp[idx - 1][1]) % mode;
            dp[idx][1] = (2LL * dp[idx - 1][0] + 3LL * dp[idx - 1][1]) % mode;
        }
        return (dp[n - 1][0] + dp[n - 1][1]) % mode;
    }
};
```