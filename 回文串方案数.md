# 回文串方案数

## 问题描述


对于一个字符串, 从前开始读和从后开始读是一样的, 我们就称这个字符串是回文串。例如"ABCBA","AA", "A" 是回文串, 而"ABCD", "AAB"不是回文串。牛牛特别喜欢回文串, 他手中有一个字符串s, 牛牛在思考能否从字 符串中移除部分(0个或多个)字符使其变为回文串，并且牛牛认为空串不是回文串。牛牛发现移除的方案可能有 很多种, 希望你来帮他计算一下一共有多少种移除方案可以使s变为回文串。对于两种移除方案, 如果移除的字符位置不一样就是不同的方案。

**输入描述**

```
输入一个字符串
```

**输出描述**
```
输出移除方案数，由于答案较大，对998244353取模
```

### 示例1
**输入**
```
aab
```
**输出**
```
4
```
**说明**
```
移除第1，2个字符
移除第1，3个字符
移除第2，3个字符
移除第3个字符
```

### 示例2
**输入**
```
abcde
```
**输出**
```
5
```
**说明**
```
任意移除4个字符 
```

## 解释说明

我们使用动态规划，```dp[i][j]```表示```i```与```j```之间存在的回文串方案数。那么存在下列的递推公式
$$
dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + 1 \wedge (s[i] == s[j]) | (- dp[i + 1][j - 1]) \wedge (s[i] != s[j])
$$

```dp[i][j]```可以这么计算：1）删掉```i```位字符后，```i + 1```与```j```之间存在的方案数；2）删掉```j```位字符后，```i```与```j - 1```之间存在的方案数。

但是，假设```s[i] == s[j]```，那么还存在两种可能性，即：
1）删除```s[i]```与```s[j]```之间的全部字符，```s[i]```与```s[j]```本身就构成回文串；
2）删除```s[i]```与```s[j]```，那```d[i][j]```还需要加上```s[i + 1]```与```s[j - 1]```之间的方案数。

假设```s[i] != s[j]```，那么就必须减掉重复计算的部分。
```C++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main(int argc, char** argv) {
    string s;
    static constexpr int mod = 998244353;
    while (cin >> s) {

        int size = s.size();
        vector<vector<int>> dp(size, vector<int>(size, 0));
        for (int idx = 0; idx < size; idx++) {
            dp[idx][idx] = 1;
        }
        int r = 0;
        for (int i = 2; i <= size; i++) {
            for (int l = 0; l <= size - i; l++) {
                r = l + i - 1;
                dp[l][r] += dp[l + 1][r];
                dp[l][r] += dp[l][r - 1];
                if (s[l] == s[r]) {
                    dp[l][r] += 1;
                }
                else {
                    dp[l][r] -= dp[l + 1][r - 1];
                }
                dp[l][r] %= mod;
                while(dp[l][r]<0) dp[l][r] += 998244353;
            }
        }
        cout << dp[0][size - 1] << endl;

    }
    return 0;
}
```