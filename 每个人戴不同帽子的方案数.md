# 每个人带不同帽子的方案数

## 题目描述

总共有$n$个人和$40$种不同的帽子，帽子编号从$1$到$40$。

给你一个整数列表的列表```hats```，其中```hats[i]```是第$j$个人所有喜欢帽子的列表。

请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。

由于答案可能很大，请返回它对```10^9 + 7```取余后的结果。

### 示例1

**输入**
```
hats = [[3,4],[4,5],[5]]
```
**输出**
```
1
```
**解释**

```
给定条件下只有一种方法选择帽子。
第一个人选择帽子 3，第二个人选择帽子 4，最后一个人选择帽子 5。
```
### 示例2

**输入**
```
hats = [[3,5,1],[3,5]]
```
**输出**
```
4
```
**解释**

```
总共有 4 种安排帽子的方法：
(3,5)，(5,3)，(1,3) 和 (1,5)
```
### 示例3

**输入**
```
hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
```
**输出**
```
24
```
**解释**

```
每个人都可以从编号为 1 到 4 的帽子中选。
(1,2,3,4) 4 个帽子的排列方案数为 24 。
```

### 示例4

**输入**
```
hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]
```
**输出**
```
111
```

**备注**
- ```n == hats.length```
- $1 \leq n \leq 10$
- $1 \leq hats[i].length \leq 40$
- $1 \leq hats[i][j] \leq 40$
- $hats[i]$包含一个数字且互不相同的整数列表

## 解释说明

我们用$f[i][mask]$表示我们处理了前$i$顶帽子，并且已经被分配帽子的人的状态为$mask$时的方案数。

对于帽子而言，我们从$1$开始编号，即$i$的范围为$[1, 40]$。具体的原因在下文的状态转移方程中会有所体现，这是为了方便存储边界条件。

对于人而言$mask$是一个长度为$n$的二进制数，它的每一位对应了一个人的状态。如果$mask$的第$k$位为$0$，那么第$k$个人还没有被分配帽子，如果为$1$，那么第$k$个人被分配了帽子。

例如当$\textit{mask} = (10010)_2$时，从右向左看，第$1$位和第$4$位为$1$，表示第$1$和$4$个人被分配了帽子，而第$2, 3, 5$个人还没有被分配帽子。根据$\textit{mask}$本身的性质，我们需要将人从$0$开始编号。

在状态的设计中，我们并没有存储每个人具体选择了哪顶帽子。这是因为在统计方案数时，我们只需要知道哪些帽子已经被选择过，以及哪些人已经选择过帽子就行了。

那么如何推导出状态转移方程呢？根据$f[i][\textit{mask}]$，我们有两种转移的方法：

- 如果第$i$顶帽子没有分配给任何人，那么会从$f[i-1][\textit{mask}]$转移而来，即表示前$i-1$顶帽子对应的分配状态就是$\textit{mask}$，而第$i$顶帽子不会对人的状态进行任何改变；

- 如果第$i$顶帽子分配给了第$j$个人，那么我们首先需要确定：
  - 第$j$个人是喜欢第$i$顶帽子的；
  - $\textit{mask}$的第$j$位为$1$，因为第$j$个人被分配了第$i$顶帽子。

在满足了这两点要求之后，$f[i][\textit{mask}]$就可以从$f[i-1][\textit{mask}']$转移而来，其中$\textit{mask}'$是将$\textit{mask}$的第$j$位变成$0$得到的值。也就是说，前$i-1$顶帽子对应的分配状态中，第$j$个人没有被分配帽子，而其它人的分配状态不变。

因此我们就可以写出状态转移方程：
$$
f[i][\text { mask }]=f[i-1][\text { mask }]+\sum_{j \in \text { mask } \wedge i \in \text { hats }[j]} f[i-1][\text { mask } \backslash j]
$$

等式右侧的第一项不需要解释。第二项求和部分的条件$j \in \textit{mask}$表示$\textit{mask}$的第$j$位为$1$，$i \in \textit{hats}$ 表示第$j$个人喜欢第$i$顶帽子，$\textit{mask} ~\backslash j$表示将$\textit{mask}$的第$j$位变成$0$。这与上文的推导过程是一致的。

动态规划的边界条件为$f[0][0] = 1$，这也是最初始的状态。最终的答案为$f[40][2^n-1]$，其中$2^n-1$是包含$n$个$1$的二进制表示对应的十进制值。

```C++
class Solution {
private:
    static constexpr int mode = 1000000007;
public:
    int numberWays(vector<vector<int>>& hats) {

        int size = hats.size();

        int maxHat = 0;
        for (int i = 0; i < size; i++){
            for (auto& h : hats[i]){
                maxHat = max(maxHat, h);
            }
        }

        vector<vector<int>> hat2people(maxHat + 1, vector<int>());
        for (int idx = 0; idx < size; idx++){
            for (auto& h : hats[idx]){
                hat2people[h].push_back(idx);
            }
        }

        vector<vector<int>> dp(maxHat + 1, vector<int>(1 << size, 0));
        dp[0][0] = 1;
        for (int i = 1; i <= maxHat; i++){
            for (int j = 0; j < (1 << size); j++){
                dp[i][j] = dp[i - 1][j];
                for (int v : hat2people[i]){
                    if (j & (1 << v)){
                        dp[i][j] += dp[i - 1][j ^ (1 << v)];
                        dp[i][j] %= mode;
                    }
                }
            }
        }
        return dp[maxHat][(1 << size) - 1];
    }
};
```