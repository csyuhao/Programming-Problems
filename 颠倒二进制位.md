# 颠倒二进制位

## 题目描述

颠倒给定的 32 位无符号整数的二进制位。

### 示例

**示例1**
```
输入：00000010100101000001111010011100
输出：00111001011110000010100101000000
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

**示例2**
```
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```

**示例3**
```
输入：00000010100101000001111010011100
输出：4176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

## 解释说明

其思想是分而治之，把数字分为两半，然后交换这两半的顺序；然后把前后两个半段都再分成两半，交换内部顺序……直至最后交换顺序的时候，交换的数字只有 1 位。

以一个 8 位的二进制数字为例：
![二进制颠倒](images/binary.jpeg)

```C++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        n = n << 16 | n >> 16;
        n = (n & 0x00ff00ff) << 8 | (n & 0xff00ff00) >> 8;
        n = (n & 0x0f0f0f0f) << 4 | (n & 0xf0f0f0f0) >> 4;
        n = (n & 0x33333333) << 2 | (n & 0xcccccccc) >> 2;
        n = (n & 0x55555555) << 1 | (n & 0xaaaaaaaa) >> 1;
        return n;
    }
};
```