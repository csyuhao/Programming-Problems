# 完成工作的最短时间

## 题目描述

给你一个整数数组```jobs```，其中```jobs[i]```是完成第$i$项工作要花费的时间。

请你将这些工作分配给$k$位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的**工作时间**是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的**最大工作时间**得以**最小化**。

返回分配方案中尽可能**最小**的**最大工作时间**。

### 示例

```
示例1：jobs = [3, 2, 3], k = 3
输出：3
解释：给每位工人分配一项工作，最大工作时间是 3 。

示例2：jobs = [1, 2, 4, 7, 8], k = 2
输出：11
解释：按照下述方式分配工作
1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）
2 号工人：4、7（工作时间 = 4 + 7 = 11）
最大工作时间是 11 。
```

**提示**
- $1 \leq k \leq \text{jobs.length} \leq 12$
- $1 \leq \text{jobs[i]} \leq 10^7$

## 解释说明

按照朴素的思路，我们按照顺序给每个工人安排工作，注意到当我们给第$i$个工人分配工作时，能够选择的分配方案仅和前$i - 1$个人被分配的工作相关。因此，我们考虑使用动态规划来解决本题，只需要记录已经被分配了工作的工人数量，以及当前已经被分配的工作是哪些即可。

因为工作数量较少，我们可以使用状态压缩的方式来表示被分配的工作是哪些。具体地，假设有$n$个工作需要进行分配，我们就可以使用一个$n$位的二进制整数来表示哪些工作已经被分配，哪些工作尚未被分配。如果该二进制的整数第$i$位表示为1，那么第$i$个工作已经被分配，否则第$i$个工作尚未被分配。如有3个工作需要被分配，那么$5 = (101)_2$即代表第$0$和$2$个工作已经被分配了，第$1$个工作尚未被分配。

这样我们可以写出状态转移方程：$f[i][j]$表示给前$i$个人分配工作，分配工作情况为$j$时，完成所有工作的最短时间。注意这里的$j$是一个二进制数，表示了分配的工作情况。实际上，我们也可以使用一个集合来表示已经分配的工作。

那么我们可以写出状态转移方程：
$$
f[i][j] = \underset{\hat{j} \in j}{\operatorname{min}} \left\{ \operatorname{max}(f[i - 1][\mathcal{C}_{j}(\hat{j})], sum[\hat{j}]) \right\}
$$
上式中，$sum[\hat{j}]$表示集合$\hat{j}$中的工作总量，$\mathcal{C}_j(\hat{j})$表示集合$j$中子集$\hat{j}$的补集。状态转移方程的实际含义是：我们枚举$j$的每个子集$\hat{j}$，让其作为分配给工人$i$的工作，这样我们只需要给前$i - 1$个人分配$\mathcal{C}_{j}(\hat{j})$的工作。


```C++

class Solution {
public:
    int minimumTimeRequired(vector<int>& jobs, int k) {
        int size = jobs.size();
        vector<int> sum(1 << size, 0);

        int x = 0, val = 0;
        for (int i = 1; i < (1 << size); i++) {
            x = __builtin_ctz(i);
            val = i - (1 << x);
            sum[i] = sum[val] + jobs[x];
        }

        vector<vector<int>> dp(k, vector<int>(1 << size, 0));
        for (int i = 0; i < (1 << size); i++) {
            dp[0][i] = sum[i];
        }

        for (int i = 1; i < k; i++) {

            for (int j = 0; j < (1 << size); j++) {


                int minn = INT32_MAX;
                for (int x = j; x != 0; x = (x - 1) & j) {
                    minn = min(minn, max(dp[i - 1][j - x], sum[x]));
                }
                dp[i][j] = minn;
            }

        }
        return dp[k - 1][(1 << size) - 1];
    }
};
```